At the highest level this project is all about handling client interactions.
This means that the all purpose of the project is to create a program that listens on a PORT 
and gives a client the opportunity to connect to this port and send a predifined set of commands
that the program will handle.

LISTENER

- Creates the socket
- Waits for connections
- Creates new connections when a client sends a request

SERVER

- Calls poll to wait for events to happen on the sockets
- Asks the listener for a new connection when a client connects 
- Ask the connection to deal with the reception/sending of messages
- Manages the removal/insertion of connections 
- Handles the removal of clients from channels 

THE LISTENER CLASS

Everything related to network (accepting connections, listening on a port) will be handled by the class Listener

The Listener class has 3 attributes

    const char* hostname; (for our purpose this is going to be "127.0.0.1" but can be modified to be any hostname)
    const char* port;     (the port it will listen on for incoming connections, this is passed to our program as an argument)
    int         socketFd; (the fd of the socket - more on sockets later)

As said before, the all purpose of the program is create a connection between our program and other programs, so..
How do we do that? 
Simply put, it will be the Listener (and a bunch of syscalls) that will make the magic happen, and the magic object that
will make this happen is the SOCKET.


NETWORKING  (SOCKETS)

What's a socket? 
Simply put we can think of a socket as a file, just as everything else in Unix, and that's why we have a socketFd in our
Listener class. Basically the socket is nothing more than a channel that makes our program and any other program communicate
with eachother over the network (that's the difference between something like a pipe)

To create the socket the Listener has a method called... createSocket (crazy right?) that looks like this

void            Listener::createSocket(int ai_family, int ai_socktype)
{
    int                 err;
    int                 yes = 1;
    struct addrinfo*    info;
    struct addrinfo*    it;
    struct addrinfo     hints;

    std::memset(&hints, 0, sizeof(hints));
    hints.ai_family = ai_family;
    hints.ai_socktype = ai_socktype;
    hints.ai_flags = AI_PASSIVE;
    err = getaddrinfo(hostname, port, &hints, &info);
    if (err != 0)
        throw std::runtime_error("Error in getting the address info");
    for (it = info; it != NULL; it = it->ai_next)
    {
        socketFd = socket(it->ai_family, it->ai_socktype | SOCK_NONBLOCK, it->ai_protocol);
        if (socketFd == -1)
            continue;
        setsockopt(socketFd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
        if (bind(socketFd, it->ai_addr, it->ai_addrlen) == 0)
            break;
    }
    err = (it == NULL);
    freeaddrinfo(info);
    if (err)
        throw std::runtime_error("Could not bind to any socket");
}

Let's walk through it step by step to understand what's going on

The first function we want to look at is getaddrinfo, the signature is the following
int getaddrinfo(char *node, char *service, struct addrinfo *hints, struct addrinfo **res);

To be honest the args names are kinda confusing but basically these are what they are :

    - node     -> name of the host (can be an IP address like "127.0.0.1" or a name like "www.ourserv.com")
    - service  -> the port where the program is listening (for example "8080")
    - hints    -> it's a struct that contains information about what kind of socket we would like to 
                  get as a result from this function, in our case we are specifing (see below for what these flags are and what they mean)
                    - ai_family = Ipv4
                    - ai_socktype = SOCK_STREAM
                    - ai_flags = AI_PASSIVE (flag used to create a socket that will be used to accept incoming connections)
    - res      -> the result of the function will be stored in this parameter, it will be a linked list
                  of structs that hold our socket option, it will be the info we pass to the syscall socket
                  to create our listening socket 
                  The important field to remember are :
                    - ai_family     -> specifies if the address is an Ipv4 or Ipv6 
                    - ai_socktype   -> specifies which type of socket we want SOCK_STREAM for an TCP connection (our case)
                                       or SOCK_DGRAM for a UDP connection (faster but less consistent, we don't use it)
                                       we also add to this socktype the flag SOCK_NONBLOCK so that any time we try to read from
                                       if there's nothing to read, our program will not wait until there will be something
                    - ai_protocol   -> It's just which kind of protocol to use (getaddrinfo will take care of this field)


NETWORKING  (BINDING)

Once we got our result back from getaddrinfo we will just traverse the linked list and try to create a new socket
with the syscall socket, using the structs that getaddrinfo returned to us, once the syscall returns success and we have
our socket we will set the socket option with setsocktopt, the all purpose of this function is just to make sure we don't get
the error "Address already in use" when calling later the function bind.
So we have our file descriptor returned from socket, if we want to associate our socket to a specific port we need to call bind,
bind will literally connect the socket to the port. We call bind like this

    bind(socketFd, it->ai_addr, it->ai_addrlen) 

We pass :
    - the socket fd
    - the address ip + port
    - the length of the address (this is necessary because ipv4 and ipv6 have different sizes)

And that's it. We have our socket binded to a port, the next step will be start listening for incoming connections, we can do that
by simply calling listen and passing the socket file descriptor and a number that specifies the queue of connections we are allowing
on this socket. That's it, that's basically all about making people able to connect to our program, to recap what we do is:


    - Call getaddrinfo 
    - Call socket with the options provided by getaddrinfo until the function gives us a valid file descriptor 
    - Call bind on the file descriptor that was returned from socket


NETWORKING (NEW CONNECTIONS)

The last method that we want to take a look at about the Listener class is the acceptConnection. 

This method will be called when a new client is trying to connect to our program (we'll see later how we can see this)
and this is what it will do 


Connection      Listener::acceptConnection() 
{
    int                     newFd;
    struct sockaddr_storage s;
    socklen_t               addrlen;

    addrlen = sizeof(s);
    newFd = accept(socketFd, (struct sockaddr*)&s, &addrlen);
    if (newFd == -1) //cannot accept more connections from this socket, stop listening
    {
        close(socketFd);
        socketFd = -1;
        throw(std::runtime_error("Reached max socket capacity"));
    }
    fcntl(newFd, F_SETFL, O_NONBLOCK);
    return (Connection(newFd, &s));
}

This method will basically call accept, a function that will take the socket file descriptor, the
struct that will hold the informations about the new connection (ip etc.) and the len of the address 
If this function returns an error it means that we reached max capacity on the socket and we will not
handle anymore incoming connections by closing the socket file descriptor. 
Otherwise accept will return us a new file descriptor that will refer to a new socket, 
this is a little bit tricky but it's important to understand.

Basically what this means is that the server has two types of sockets, one that is the listener socket 
and is only used for giving the clients a way to connect to our server. Once a client tries to connect
the listener socket will receive a packet telling that there's someone that wants to create a new connection,
this connection is then created on a NEW socket, that will be the one responsible for handling the communication
between our server and the client.

We can think of the listener socket as some kind of door bell, our program is the hotel and if someone wants to 
gets in it will have to ring the door bell (send a packet to our listener socket), this will tell our program
that a new guest has arrived and we can open the door and let him in, the function accept is like the person at the
hotel entrance that will do the check in for the new guest. It will take its information and store it in the struct we
pass to the function and then will return the room (the socket file descriptor) where the person can stay and be in our
hotel (the server)


THE SERVER CLASS

Ok that's really it for the networking part, let's take a look now at the Server class

Our server class is the police man of the program, it basically checks everything that's going on and acts after events
happen according to some rules.

ATTRIBUTES

First of all this are the attributes of the server


private:
    Listener                                        listener;
    std::string                                     password;
    std::vector<pollfd>                             polls;
    std::list<Connection>                           connections;
    std::map<const std::string, Channel>            channels;
    std::map<int, Connection*>                      fdToConnection;
    std::map<const std::string, Connection*>        nickToConnection;
    connectionID                                    currentId;


the server has a listener that is the one we just talked about. 
The password is what you have to give to our program with the PASS command in order to get into the server 
Then we have 

    - A vector of pollfd (more about it later)
    - A list of Connection classes which is a linked list of all the clients connected to the server 

    3 different maps, all of them are used for efficiency reasons, and are used just to get a specific object (channel/connection)
    by using one of its attributes (nickname, name of the channel, connection file descriptor). Maps are not needed, you could
    implement everything only with lists/vectors but it would be very inefficient.
    The maps are :
    - A map of string to Channel class which is used to store all the channels on the server, this map at the same time
      is used to retrieve a channel from its name,

    - A map of file descriptors to Connection pointers (apparently you cannot have references so that's why pointers are used).
      The reaosn why this is used will be clear later when we talk about pollfd.

    - A map of string (nickname) to Connection pointers again, this is used to get the Connection class of a client just by
      having its name (very important when we get a command like send a private message to person "x" and so we can get 
      fast the Connection of person "x" just by looking at this map).

Last there's the currentId. Basically everytime a new connection is created it will be assigned a unique ID that will never change,
this is important because people can change their nickname on the server and so a nickname is not a good way to identify a single 
connection. The type is connectionID but this is just a typedef for a long (typedef long    connectionID; in  the Connection.hpp)


POOL EVENTS

Well the most important thing to know about the Server class is how it does input/output operations and in general we need to
answer the question : how does the server knows when it received a message from a client?

Very simple, it uses another syscall! Strange uh? 
Basically this is done in the method pollEvents() by calling poll.
The method looks like this  


void Server::pollEvents()
{
    int ret;

    ret = poll(polls.data(), polls.size(), EVENT_TIMEOUT_TIME);
    if (ret == -1)
        throw(std::runtime_error("Poll error"));
    for (size_t i = 0; i < polls.size(); i++)
    {
        if (polls.at(i).revents != 0) //io event happened on fd
        {
            if (i == 0)
                createConnection();
            else
                handleClientInteraction(polls.at(i));
        }
    }
    checkForTimeouts();
}

What we do is pass to poll function 3 things, first the array of pollfd structs (see below), then the
number of pollfds we have and the last parameter is the amount of milliseconds we want to wait for an 
event to happen, if no event happens in the time specified, poll will return 0.

Remember in our server we have this vector?

    std::vector<pollfd> polls; 

Yeah it's time to talk about it. What is a pollfd? Very simply is just a struct that 
we use to pass information to the function poll. The struct looks like this

struct pollfd {
               int   fd;         -> It's the file descriptor of the connection's socket, the one returned from the call accept
               short events;     -> Which kind of event we want poll to check for, in our case it will always start as POLLIN
                                    which means that we want poll to notify us when there's data that was sent FROM the client
                                    to the socket (so we are polling IN our server new data)
                                    The other option we can specify is POLLOUT which means that we are asking poll to notify us
                                    when we can SEND to the client a new message. (this is an option we well add only when 
                                    we have a message to send to the client, we don't set it by default otherwise we will have
                                    everytime a notification from poll saying that the client can receive a message)
               short revents;    -> This field will be set by the poll function when there's a new event from the ones we specified
                                    in the field events. That's why you see the  
                                                if (polls.at(i).revents != 0) line of code in the pollEvents method. 
           };

So what's happening in this method is that we are calling Poll and wait for it to return, poll will do its job and 
watch on each of the file descriptors we passed (by the way this is called IO MULTIPLEXING) and once something happens will return to 
us and we can then traverse the vector of polls we have and check what happened, one thing to notice is that our first pollfd refers 
to the listener socket that's why there's the line 

            if (i === 0) createConnection()

The only thing that can trigger our listener is a new incoming connection so we will act accordingly
Otherwise we will just handle the client interaction, most of the interaction with the client is handled by the Connection class.
The important thing here is that the server will check if the event received is 

    - a POLLHUP (the client hung up the connection and we will close it)
    - a POLLOUT (in which case the connection will handle sending the message to the client and the only thing the server has to check is if
                there's was an error in sending the message in which case it will close the connection or if the message sent was
                a message of closed connection (yeah there's a strange stuff in the irc that before closing a connection you need
                to notify the client that you are closing the connection and only after that you can close it)) 

    - a POLLIN (the client sent us a message, we check if there are any error and if not we make sure we received the endline, if that's 
                the case we pass to handling the command, see below)

HANLDING COMMANDS 

Handling commands is quite an easy job for the server, all it has to do is to split the whole message in lines (since each line has a different command)
and then split the line in a vector of words, where the first word is the command, and the rest are the arguments. This job is done by the method

handleClientCommand()

After we have our vector of words we will pass it to handleSimpleCommand() that will match the command received with the ones that are
available on this server, if the command is not recognized the server will silently fail, meaning no error message is sent to the client.


HANDLING CONNECTIONS

The last important thing to know about how the server works is how it handles connections.
As stated before the connections are stored in a list, at the same time we also have a map of strings to connections pointers,
and also each connection has its own file descriptor that is stored in the vector of pollfd. So when a connection is created these are
the steps that we need to take in order to register it properly:

    - Create the connection (this is done by our server with the method createConnection()) by adding it to the list of connections
    - Assign a poll struct to the new Connection created since each connection stores internally a pointer to its own pollfd

To instead remove a connection from the server we just need to :

    - Remove the client from the channel he's is 
    - Remove the connection from the map of nicknames to connections 
    - Remove the connection from the map of fds to connections 
    - Remove the connection by erasing it from the list of connections
    - Set the pollfd file descriptor to -1 so that it will be ignored from
      the next calls to poll (we could also remove it directly from the vector
      but this way is more efficient)
